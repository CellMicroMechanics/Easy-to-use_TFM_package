% Copyright (C) 2010 - 2019, Sabass Lab
%
% This program is free software: you can redistribute it and/or modify it 
% under the terms of the GNU General Public License as published by the Free
% Software Foundation, either version 3 of the License, or (at your option) 
% any later version. This program is distributed in the hope that it will be 
% useful, but WITHOUT ANY WARRANTY; without even the implied warranty of 
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General 
% Public License for more details. You should have received a copy of the 
% GNU General Public License along with this program.
% If not, see <http://www.gnu.org/licenses/>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%DESCRIPTION
%Calculation of traction forces with the regularized Fourier transform
%approach

%------------------
%FUNCTION ARGUMENTS 
%Ftux: x component of displacement matrix in Fourior space
%Ftuy: y component of displacement matrix in Fourior space
%L: regularization parameter
%E: Young's modulus
%s: Poisson's ratio
%cluster_size: grid spacing in pixels
%i_max, j_max: sizes of grid
%grid_mat: regular grid with size i_max*j_max 
%pix_durch_my: size of one pixel in micrometer
%zdepth: depth of focal plane below the surface (positive distance in micrometers)
%------------------

%------------------
%FUNCTION OUTPUTS
%f_pos: postion of traction forces 
%f_nm_2: traction nm*2 matrix 
%f_magnitude: magnitude of traction
%f_n_m: traction n*m*2 matrix
%Ftfx: x component of traction in Fourior space
%Ftfy: y component of traction in Fourior space
%------------------

function [f_pos,f_nm_2,f_magnitude,f_n_m, Ftfx, Ftfy] = reg_fourier_TFM(Ftux,Ftuy,L,E,s,cluster_size,i_max, j_max, grid_mat, pix_durch_my,zdepth)

    V = 2*(1+s)/E;
    kx_vec = 2*pi/i_max/cluster_size.*[0:(i_max/2) (-(i_max/2-1):-1)];
    ky_vec = 2*pi/j_max/cluster_size.*[0:(j_max/2) (-(j_max/2-1):-1)];
    kx = repmat(kx_vec',1,j_max);
    ky = repmat(ky_vec,i_max,1);
    kx(1,1) = 1;
    ky(1,1) = 1;
    
     if  nargin == 8   %Slim output. Calculate only traction forces for the case z=0
         Ginv_xx = (kx.^2+ky.^2).^(-1/2).*V.*(kx.^2.*L+ky.^2.*L+V.^2).^(-1).*(kx.^2.* ...
                 L+ky.^2.*L+((-1)+s).^2.*V.^2).^(-1).*(kx.^4.*(L+(-1).*L.*s)+ ...
                 kx.^2.*((-1).*ky.^2.*L.*((-2)+s)+(-1).*((-1)+s).*V.^2)+ky.^2.*( ...
                 ky.^2.*L+((-1)+s).^2.*V.^2));
         Ginv_yy =  (kx.^2+ky.^2).^(-1/2).*V.*(kx.^2.*L+ky.^2.*L+V.^2).^(-1).*(kx.^2.* ...
                   L+ky.^2.*L+((-1)+s).^2.*V.^2).^(-1).*(kx.^4.*L+(-1).*ky.^2.*((-1)+ ...
                   s).*(ky.^2.*L+V.^2)+kx.^2.*((-1).*ky.^2.*L.*((-2)+s)+((-1)+s).^2.* ...
                   V.^2));
         Ginv_xy =  (-1).*kx.*ky.*(kx.^2+ky.^2).^(-1/2).*s.*V.*(kx.^2.*L+ky.^2.*L+ ...
                   V.^2).^(-1).*(kx.^2.*L+ky.^2.*L+((-1)+s).*V.^2).*(kx.^2.*L+ky.^2.* ...
                   L+((-1)+s).^2.*V.^2).^(-1);

         Ginv_xx(1,1) = 0;
         Ginv_yy(1,1) = 0;
         Ginv_xy(1,1) = 0;
         
         Ginv_xy(i_max/2+1,:) = 0;
         Ginv_xy(:,j_max/2+1) = 0;
         Ftfx = Ginv_xx.*Ftux + Ginv_xy.*Ftuy;
         Ftfy = Ginv_xy.*Ftux + Ginv_yy.*Ftuy;
           
         %simply set variables that we do not need to calculate here to 0 
         f_pos = 0;
         f_nm_2 = 0;
         f_magnitude = 0;
         f_n_m = 0;
         
         
     else   %full output, calculate traction forces with z>=0 
            z = zdepth/pix_durch_my; 
            X = i_max*cluster_size/2;
            Y = j_max*cluster_size/2; 
            if z == 0
                g0x = pi.^(-1).*V.*((-1).*Y.*log((-1).*X+sqrt(X.^2+Y.^2))+Y.*log( ...
                X+sqrt(X.^2+Y.^2))+((-1)+s).*X.*(log((-1).*Y+sqrt(X.^2+Y.^2) ...
                )+(-1).*log(Y+sqrt(X.^2+Y.^2))));

                g0y = pi.^(-1).*V.*(((-1)+s).*Y.*(log((-1).*X+sqrt(X.^2+Y.^2))+( ...
                -1).*log(X+sqrt(X.^2+Y.^2)))+X.*((-1).*log((-1).*Y+sqrt( ...
                X.^2+Y.^2))+log(Y+sqrt(X.^2+Y.^2))));
            else
                g0x = pi.^(-1).*V.*(((-1)+2.*s).*z.*atan(X.^(-1).*Y)+(-2).*z.* ...
                atan(X.*Y.*z.^(-1).*(X.^2+Y.^2+z.^2).^(-1/2))+z.*atan(X.^( ...
                -1).*Y.*z.*(X.^2+Y.^2+z.^2).^(-1/2))+(-2).*s.*z.*atan(X.^( ...
                -1).*Y.*z.*(X.^2+Y.^2+z.^2).^(-1/2))+(-1).*Y.*log((-1).*X+ ...
                sqrt(X.^2+Y.^2+z.^2))+Y.*log(X+sqrt(X.^2+Y.^2+z.^2))+(-1).* ...
                X.*log((-1).*Y+sqrt(X.^2+Y.^2+z.^2))+s.*X.*log((-1).*Y+sqrt( ...
                X.^2+Y.^2+z.^2))+(-1).*((-1)+s).*X.*log(Y+sqrt(X.^2+Y.^2+ ...
                z.^2)));

                g0y = (-1).*pi.^(-1).*V.*(((-1)+2.*s).*z.*atan(X.^(-1).*Y)+(3+(-2) ...
                .*s).*z.*atan(X.*Y.*z.^(-1).*(X.^2+Y.^2+z.^2).^(-1/2))+z.* ...
                atan(X.^(-1).*Y.*z.*(X.^2+Y.^2+z.^2).^(-1/2))+(-2).*s.*z.* ...
                atan(X.^(-1).*Y.*z.*(X.^2+Y.^2+z.^2).^(-1/2))+Y.*log((-1).* ...
                X+sqrt(X.^2+Y.^2+z.^2))+(-1).*s.*Y.*log((-1).*X+sqrt(X.^2+ ...
                Y.^2+z.^2))+((-1)+s).*Y.*log(X+sqrt(X.^2+Y.^2+z.^2))+X.*log( ...
                (-1).*Y+sqrt(X.^2+Y.^2+z.^2))+(-1).*X.*log(Y+sqrt(X.^2+Y.^2+ ...
                z.^2)));
            end

           Ginv_xx =exp(sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2).^(-1/2).*V.*(exp( ...
              2.*sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2).*L+V.^2).^(-1).*(4.* ...
              ((-1)+s).*V.^2.*((-1)+s+sqrt(kx.^2+ky.^2).*z)+(kx.^2+ky.^2) ...
              .*(4.*exp(2.*sqrt(kx.^2+ky.^2).*z).*L+V.^2.*z.^2)).^(-1).*(( ...
              -2).*exp(2.*sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2).*L.*((-2).* ...
              ky.^2+kx.^2.*((-2)+2.*s+sqrt(kx.^2+ky.^2).*z))+V.^2.*( ...
              kx.^2.*(4+(-4).*s+(-2).*sqrt(kx.^2+ky.^2).*z+ky.^2.*z.^2)+ ...
              ky.^2.*(4+4.*((-2)+s).*s+(-4).*sqrt(kx.^2+ky.^2).*z+4.*sqrt( ...
              kx.^2+ky.^2).*s.*z+ky.^2.*z.^2)));
            Ginv_yy = exp(sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2).^(-1/2).*V.*(exp( ...
              2.*sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2).*L+V.^2).^(-1).*(4.* ...
              ((-1)+s).*V.^2.*((-1)+s+sqrt(kx.^2+ky.^2).*z)+(kx.^2+ky.^2) ...
              .*(4.*exp(2.*sqrt(kx.^2+ky.^2).*z).*L+V.^2.*z.^2)).^(-1).*( ...
              2.*exp(2.*sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2).*L.*(2.* ...
              kx.^2+(-1).*ky.^2.*((-2)+2.*s+sqrt(kx.^2+ky.^2).*z))+V.^2.*( ...
              kx.^4.*z.^2+(-2).*ky.^2.*((-2)+2.*s+sqrt(kx.^2+ky.^2).*z)+ ...
              kx.^2.*(4+4.*((-2)+s).*s+(-4).*sqrt(kx.^2+ky.^2).*z+4.*sqrt( ...
              kx.^2+ky.^2).*s.*z+ky.^2.*z.^2)));
            Ginv_xy = (-1).*exp(sqrt(kx.^2+ky.^2).*z).*kx.*ky.*(kx.^2+ky.^2).^( ...
              -1/2).*V.*(exp(2.*sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2).*L+ ...
              V.^2).^(-1).*(2.*exp(2.*sqrt(kx.^2+ky.^2).*z).*(kx.^2+ky.^2) ...
              .*L.*(2.*s+sqrt(kx.^2+ky.^2).*z)+V.^2.*(4.*((-1)+s).*s+(-2) ...
              .*sqrt(kx.^2+ky.^2).*z+4.*sqrt(kx.^2+ky.^2).*s.*z+(kx.^2+ ...
              ky.^2).*z.^2)).*(4.*((-1)+s).*V.^2.*((-1)+s+sqrt(kx.^2+ ...
              ky.^2).*z)+(kx.^2+ky.^2).*(4.*exp(2.*sqrt(kx.^2+ky.^2).*z).* ...
              L+V.^2.*z.^2)).^(-1);

            Ginv_xx(1,1) = 1/g0x;
            Ginv_yy(1,1) = 1/g0y;
            Ginv_xy(1,1) = 0;
            Ginv_xy(i_max/2+1,:) = 0;
            Ginv_xy(:,j_max/2+1) = 0;

            Ftfx = Ginv_xx.*Ftux + Ginv_xy.*Ftuy;
            Ftfy = Ginv_xy.*Ftux + Ginv_yy.*Ftuy;

            f_n_m(:,:,1) = ifft2(Ftfx,'symmetric');
            f_n_m(:,:,2) = ifft2(Ftfy,'symmetric');

            f_nm_2(:,1) = reshape(f_n_m(:,:,1),i_max*j_max,1);
            f_nm_2(:,2) = reshape(f_n_m(:,:,2),i_max*j_max,1); 

            f_pos(:,1) = reshape(grid_mat(:,:,1),i_max*j_max,1);
            f_pos(:,2) = reshape(grid_mat(:,:,2),i_max*j_max,1);

            f_magnitude = (f_nm_2(:,1).^2 + f_nm_2(:,2).^2).^0.5;
     end
    
end